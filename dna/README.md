Μου ζητήθηκε να γράψω έναν αλγόριθμο ο οποίος θα εντοπίζει την μέγιστη κοινή αλυσίδα ανάμεσα σε δύο dna.
Αρχικά,εισήγαγα τις βιβλιοθήκες που μου χρειάζονται. Χρειάστηκα και μία ποιο διαφορετική την <string.h> για την χρήση διαφόρων συναρτήσεων που με βοηθάνε με την επεξεργασία διαφόρων string καθώς και με διάφορους υπολογισμούς σχετικά με αυτά.
Έπειτα, τα αρχεία μου τα λαμβάνω από την γραμμή εντολών ως ορίσματα και τα ανοίγω με fopen η οποία περιέχεται στην stdio.h , αν για κάποιο λόγο τα αρχεία δεν ανοιχτούν ο αλγόριθμος τερματίζει με κωδικό εξόδου 1.
Στους πίνακες τύπου char αποθηκεύω  τις βάσεις των δύο αρχείων ξεχωριστά με μέγιστο αριθμό αυτών των βάσεων το 1000 για το κάθε αρχείο.
Στην συνάρτηση malloc βάζω ως μέγιστο αριθμό των χαρακήρψν/bytes το 100001 καθώς λαμβάνω υπόψη  και το null byte με το οποίο τερματίζουν τα αρχεία μας καθώς αυτά πρόκεινται για συμβολοσειρές.
Την θέση του null byte την υπολογίζω μέσω των χαρακτήρων  που διάβασε η fread.
Οι μεταβλητές count και max ψρησιμοποιούνται για τον υπολοσμό του μήκους την κοινής αλυσίδας και το μέγιστο μήκος αντίστοιχα.
Για την εύρεση της αλυσίδας εξετάζω κάθε ένα απο τα στοιχεία του buffer1 με όλα τα στοιχεία του buffer2 και αν βρω κάποιο κοινό μεταξύ αυτών των δύο τότε εξετάζω τα επόμενα στοιχέια ουσιαστικά εξετάζω παράλληλα αυτούς τους 2 πίνακες
Επιπροσθέτως, αν κάποιος χαρακτήρας του πίνακα buffer1 ή του buffer2 είναι διάφορος των παραπάνω επιτρεπτών βάσεων απλά τον αγνωούμε με την χρήση της εντολής continue η οποία μας πηγαίνει στην επόμενη επανάληψη. 
Κατόπιν, γίνεται έλεγχος για το αν ο αριθμός των κοινών χαρακτήρων ανάμεσα στους 2 πίνακες buffer1 και buffer2 που "δημιουργήθηκε" στην i-οστή επανάληψη ξεπερνάει τον μέγιστο αριθμό αυτών που έχει επίσης που με την σειρά του έχει επίσης δημιουργηθεί.
Η δημιουργία του δυναμικού πίνακα teliko έχει σκοπό να  αντιγραφούν τα στοιχεία που έχουν περαστεί κατα την i-οστή επανάληψη στον επίσης δυναμικό πίνακα χαρακτήρων array μέσω της συνάρτησης strcpy που βρίσκεται στο stdio.h.
Αποδεσμεύουμε την μνήμη του δυναμικού πίνακα array και την ξαναδεσμεύουμε για να να τροφοδοτηθέι με  νέα κοινά στοιχέια/χαρακτήρες.
Επειδή υπάρχει η περίπτωση η μέγιστη κοινή αλυσίδα να βρίσκεται στην αρχή του ενός και στο τέλος του άλλου εξετάζουμε για κάθε γράμμα του πρώτου dna όλα τα γράμματα του δεύτερου.
Τελικά, εκτυπώνουμε την μέγιστη κοινή αλυσίδα και αποδεσμεύμε όλη την μνήμη που δεσμεύσαμε αποφεύγοντας το λεγόμενο leak memory καθώς και το κλείσιμο των αρχείων που ανοίξαμε στην αρχή.
Αν όλα πάνε καλά το πρόγραμμα επιστρέφει με exit code το 0.

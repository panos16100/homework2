#include <stdio.h>
#include <stdlib.h>  //χρησιμοποιώ το αρχείο κεφαλίδας stdlib.h για την χρήση της συνάρτησης malloc και free
#include <string.h>  //χρησιμοποιώ το αρχείο κεφαλίδας string.h  για την συνάρτηση strcpy


int main(int argc,char *argv[]){
    if(argc!=3){ /*ο επιτρεπτός αριθμός ορισμάτων στην γραμμή εντολών είναι 3(2 τα ονόματα των αρχείων και
   1 το όνομα του εκτελέσιμου προγράμματος)*/
        printf("sorry but you have to check it again\n");
        return 1;
    }
    /*με την χρήση της συνάρτησης fopen η οποια ορίζεται στο αρχείο κεφαλίδας
    stdio.h μας επιτρέπεται το άνοιγμα των αρχείων, τα ονόματα των οποίων έχουν περαστεί ως ορίσματα 
    στην γραμμή εντολών*/
    FILE *filetoread1=fopen(argv[1],"rb");
    FILE *filetoread2=fopen(argv[2],"rb");
    if (!filetoread1){
        printf("file1 does not exists\n");
        return 1;
    }
    else if(!filetoread2){
        printf("file2 does not exists\n");
        return 1;
    } /*αν δεν ανοίγει οποιοδήποτε απο τα αρχεία για οποιονδήποτε λόγο τότε το πρόγραμμα επιστρέφει με κωδικό
    εξόδου το 1 εμφανίζοντας κατάλληλο μήνυμα*/
    char *buffer1=malloc(100001*sizeof(char));
    char *buffer2=malloc(100001*sizeof(char));
    /*στους πίνακες τύπου char αποθηκεύω  τις βάσεις των δύο αρχείων ξεχωριστά με μέγιστο αριθμό αυτών των βάσεων
    το 1000 για το κάθε αρχείο*/
    /*στην συνάρτηση malloc βάζω ως μέγιστο αριθμό των χαρακήρψν/bytes το 100001 καθώς λαμβάνω υπόψη  και το null
    byte με το οποίο τερματίζουν τα αρχεία μας καθώς αυτά πρόκεινται για συμβολοσειρές*/
    size_t diabasa1=fread(buffer1,sizeof(char),100000,filetoread1);
    size_t diabasa2=fread(buffer2,sizeof(char),100000,filetoread2);
    /*η συνάρτηση fread  επιστέφει τον αριθμό των δεδομένων που διαβάστηκαν απο τα αρχεία μας και τον αποθηκεύει
  στις ακέραιες μεταβλητές diabasa1 για το πρώτο αρχείο και diabasa2 για το δεύτερο αρχείο*/
    buffer1[diabasa1]='\0';
    buffer2[diabasa2]='\0';
    size_t i,j,k;
    long int count,max=0; /*με την ακέραια μεταβλητή count μετράω τον  συνεχόμενο αριθμό των κοινών χαρακτήρων 
    ανάμεσα στους 2 πίνακες*/
    /*με την επίσης ακέραια μεταβλητή max είμαστε σε θέση να εντοπίσουμε τον μέγιστο συνεχόμενο αριθμό των κοινών
    χαρακτήρων ανάμεσα στους 2 πίνακες*/
    char *array=malloc(100001*sizeof(char)); /*ο πίνακας array λειτουργεί ως προσωρινός/μεταβαλλόμενος πίνακας
    στον οποίο θα αποθηκεύω κάθε φορά τα κοινά*/
    char *teliko=malloc(1*sizeof(char));// απλή δημιουργία του δυναμικού πίνακα teliko
    /*εξετάζω κάθε ένα απο τα στοιχεία του buffer1 με όλα τα στοιχεία του buffer2 και αν βρω κάποιο κοινό μεταξύ
    αυτών των δύο τότε εξετάζω τα επόμενα στοιχέια */
    //ουσιαστικά εξετάζω παράλληλα αυτούς τους 2 πίνακες
    for(i=0;i<diabasa1;i++){
       if((buffer1[i]!='A')&&(buffer1[i]!='C')&&(buffer1[i]!='T')&&(buffer1[i]!='G')){
         /*αν κάποιος χαρακτήρας του πίνακα buffer1 είναι διάφορος των παραπάνω επιτρεπτών βάσεων απλά τον αγνωούμε
    με την χρήση της εντολής continue η οποία μας πηγαίνει στην επόμενη επανάληψη (i++)*/
        continue;
       }
       k=i;
       count=0;
        for(j=0;(j<diabasa2) &&(buffer1[k]!='\0');j++){
            if((buffer2[j]!='A')&&(buffer2[j]!='C')&&(buffer2[j]!='T')&&(buffer2[j]!='G')){
               /*αν κάποιος χαρακτήρας του πίνακα buffer2 είναι διάφορος των παραπάνω επιτρεπτών βάσεων απλά τον αγνωούμε
    με την χρήση της εντολής continue η οποία μας πηγαίνει στην επόμενη επανάληψη (j++)*/
                continue;
            } 
            if(buffer1[k]==buffer2[j]){ //κοινός χαρακτήρας/βάση ανάμεσα στους 2 πίνακες
                array[count]=buffer2[j];
                count++;
                k++;/*η ακέραια μεταβλητή k μας βοηθά στο να έχουμε πρόσβαση στο επόμενο στοιχείο του πίνακα buffer1
        ώστε να το συγκρίνουμε με το ακριβώς επόμενο απο τον j-οστό στοιχείο του πίνακα buffer2*/

            }else{
                if(count>max){  /*έλεγχος για το αν ο αριθμός των κοινών χαρακτήρων ανάμεσα στους 2 πίνακες buffer1 
        και buffer2 που "δημιουργήθηκε" στην i-οστή επανάληψη ξεπερνάει τον μέγιστο αριθμό αυτών που έχει επίσης
        που με την σειρά του έχει επίσης δημιουργηθεί*/

                    max=count;
                    free(teliko);
                    array[max]='\0';//οι συμβολοσειρές/πίνακες χαρακτήρων πρέπει πάντα να τελειώνουν με το null byte
                    teliko=malloc((max+1)*sizeof(char));/*δημιουργία του δυναμικού πίνακα teliko στον οποίο θα αντιγραφούν
            τα στοιχεία που έχουν περαστεί κατα την i-οστή επανάληψη στον επίσης δυναμικό πίνακα χαρακτήρων array 
            μέσω της συνάρτησης strcpy που βρίσκεται στο stdio.h*/

                    strcpy(teliko,array);
                }
                free(array);/*αποδέσμευση μνήμης για τον προσωρινό πίνακα array όταν συναντήσουμε διαφορετικό στοιχείο
                ανάμεσα στους 2 πίνακες*/ 
                array=malloc(100001*sizeof(char));/*δημιορυγία δυναμικής μνήμης για τον πίνακα array ο οποίος πιθανώς στην 
            συνέχεια να τροφοδοτηθέι με  νέα κοινά στοιχέια/χαρακτήρες*/
                count=0;/*refresh της μεταβλητής count καθώς το "σερί" των κοινών χαρακτήρψν έσπασε*/
                k=i;/*είμαστε στο ίδιο i-οστο στοιχείο της πρώτης for loop και το εξετάζουμε με όλα τα στοιχεία
            της δεύτερης(εμφωλευμένης) for loop*/
            }


        }
        //σε περίπτωση που στην  j-η τελευταία επανάληψη της for loop υπάρχει κοινό στοιχείο
        if(count>max){
            max=count;
            free(teliko);
            array[max]='\0';
            teliko=malloc((max+1)*sizeof(char));
            strcpy(teliko,array);
        }
        free(array);
        array=malloc(100001*sizeof(char));

    }
    
    printf("%s\n",teliko); //εκτύπωση της μέγιστης κοινής συμβολοσειράς μεταξύ των δύο αρχείων
    //αποδεσμευση μνήμης για τους δυναμικούς πίανκες που δημιουργήσαμε για να μην υπάρχει το λεγόμενο leak memory
    free(array);
    free(teliko);
    free(buffer1);
    free(buffer2);
    //με την συνάρτηση fclose  η οποία ορίζεται στο stdio.h κλείνουμε τα αρχεία μας
    fclose(filetoread1);
    fclose(filetoread2);
    return 0; //αν όλα πάνε καλά το πρόγραμμα επιστρέφει με exit code το 0

    
}
